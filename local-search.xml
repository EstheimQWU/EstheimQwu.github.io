<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式2</title>
    <link href="/2020/08/12/0004/"/>
    <url>/2020/08/12/0004/</url>
    
    <content type="html"><![CDATA[<p>代理模式、原型模式与观察者模式；单一职责原则、开放封闭原则、里氏代换原则/依赖倒转原则</p><a id="more"></a><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>Proxy:</strong> 为其他对象提供一种代理以控制对这个对象的访问。<br>1、应用场景<br>1.1、远程代理，为一个对象在不同的地址空间提供局部代表。<br>1.2、虚拟代理<br>1.3、智能指引<br>1.4、安全代理</p><p>2、应用步骤<br>2.1、确定代理类、真实实体类及两者的共用接口。<br>2.2、通过继承代理接口分别实现真实实体类与代理类。<br>2.3、若没有实例化RealSubject，则实现RealSubject。</p><pre><code class="hljs routeros">AbstractEntity.csabstract class<span class="hljs-built_in">/interface </span>AbstractEntity&#123;    public abstract void Request();&#125;</code></pre><pre><code class="hljs arduino">Entity.cs<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span> :</span> AbstractEntity&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;ping!&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs routeros">Proxy.csclass<span class="hljs-built_in"> Proxy </span>: AbstractEntity&#123;    Entity entity;    public override void Request()&#123;        <span class="hljs-keyword">if</span> ()&#123;            entity = new Entity();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs routeros">static void Main(string[] args)&#123;<span class="hljs-built_in">    Proxy proxy </span>= new Proxy();    proxy.Request();&#125;</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>Prototype:</strong> 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>原型模式就是从一个对象再创建另外一个可定制的对象，过程中不必知晓创建的细节。<br>1、应用场景<br>1.1、在初始化信息不发生变化的前提下，克隆可以隐藏对象创建的细节，又可以提高性能。</p><p>2、应用步骤<br>2.1、在抽象原型类中创建一个原型克隆方法。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function">Prototype <span class="hljs-title">Clone</span><span class="hljs-params">()</span></span>;</code></pre><p>2.2、在具体原型类中实现这个克隆方法，视情况使用深复制与浅复制。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>Publish/Subscribe:</strong> 发布订阅模式，让多个观察者对象同时监听某一个主题对象。这个主题对象能够在状态发生变化时，通知所有观察者对象，使得他们自动更新自己。<br>1、应用场景<br>1.1、当一个对象的改变需要同时改变其他对象时，适合使用观察者模式。<br>1.2、用于解除耦合，使得耦合的双方依赖于抽象而非具体的类。<br><img src="https://i.loli.net/2020/08/12/OUexfvhdGXpo1A5.png" alt="Capture.PNG"><br>2、应用步骤<br>2.1、确定观察者与通知者。<br>2.2、建立抽象关系。</p><h4 id="事件委托模式"><a href="#事件委托模式" class="headerlink" title="事件委托模式"></a>事件委托模式</h4><p>1、通过抽象接口替换抽象类达成进一步的耦合降低。<br>2、可通过指针或者delegate实现的特殊类实现。</p><pre><code class="hljs csharp">C<span class="hljs-meta">#</span><span class="hljs-function"><span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>(<span class="hljs-params"></span>)</span>;</code></pre><p><strong>一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。</strong></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>SRP:</strong> Single responsibility principle，就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果能够想到多于一个的动机去改变一个类，那么这个类就是具有多于一个的职责，应该考虑类的职责分离。</p><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p><strong>OPEN-CLOSE:</strong> Open for extension, Closed for modification，软件实体（类，模块，函数）应该是可以拓展却不能够修改的。</p><h3 id="里氏代换原则-依赖倒转原则"><a href="#里氏代换原则-依赖倒转原则" class="headerlink" title="里氏代换原则/依赖倒转原则"></a>里氏代换原则/依赖倒转原则</h3><p><strong>LSP:</strong> Liskov Substitution Principle，如果一个软件实体使用的是一个父类的话，那么它一定也适用于其子类，而且它察觉不出父类对象与子类对象的区别。——<strong>子类型必须能够替换掉它们的父类型。</strong></p><p><strong>DIP:</strong> Dependence Inversion Principle，程序要依赖于抽象接口，不要依赖于具体实现；抽象不应该依赖于细节，细节应该依赖于抽象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/08/11/0003/"/>
    <url>/2020/08/11/0003/</url>
    
    <content type="html"><![CDATA[<p>单例模式、简单工厂、策略模式、装饰模式与命令模式。</p><a id="more"></a><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单线程情况"><a href="#单线程情况" class="headerlink" title="单线程情况"></a>单线程情况</h4><p>步骤1、新建单例类，并且用private改写其构造方法，使得类无法被其他方法实例化。<br>步骤2、在单例类中声明静态的实例化对象。<br>步骤3、在单例类中新建静态方法，返回一个单例的实例化对象。</p><h4 id="多线程加锁情况"><a href="#多线程加锁情况" class="headerlink" title="多线程加锁情况"></a>多线程加锁情况</h4><p><strong>lock确保当一个线程位于代码的临界区时，另一个线程不再进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（被阻止），直到该对象被释放。</strong></p><h5 id="双重枷锁"><a href="#双重枷锁" class="headerlink" title="双重枷锁"></a>双重枷锁</h5><h5 id="C-语境"><a href="#C-语境" class="headerlink" title="C#语境"></a>C#语境</h5><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;    <span class="hljs-comment">// 声明</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">object</span> syncRoot = <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>();<span class="hljs-comment">// 静态只读</span>    <span class="hljs-comment">// 私有的构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;    &#125;    <span class="hljs-comment">// 实例化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">lock</span> (syncRoot) &#123;                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="JAVA语境"><a href="#JAVA语境" class="headerlink" title="JAVA语境"></a>JAVA语境</h5><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-comment">// 声明</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object syncRoot = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 静态只读</span>    <span class="hljs-comment">// 私有的构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-comment">// 实例化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (syncRoot)&#123; <span class="hljs-comment">// 另一种写法：Synchronize （Singleton.class）</span>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="PYTHON语境"><a href="#PYTHON语境" class="headerlink" title="PYTHON语境"></a>PYTHON语境</h5><pre><code class="hljs reasonml">import timeimport threading<span class="hljs-keyword">class</span> <span class="hljs-constructor">Singleton(<span class="hljs-params">object</span>)</span>:    _instance_lock = threading.<span class="hljs-constructor">Lock()</span>    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>,<span class="hljs-operator">*</span><span class="hljs-params">args</span>,<span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span>:        time.sleep(<span class="hljs-number">1</span>)    @classmethod    def get<span class="hljs-constructor">_instance(<span class="hljs-params">cls</span>,<span class="hljs-operator">*</span><span class="hljs-params">args</span>,<span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span>:        <span class="hljs-keyword">if</span> not hasattr(Singleton,&#x27;_instance&#x27;):            <span class="hljs-keyword">with</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span><span class="hljs-module"><span class="hljs-identifier">_instance_lock</span>:</span></span>                <span class="hljs-keyword">if</span> not hasattr(Singleton,&#x27;_instance&#x27;):                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span><span class="hljs-module"><span class="hljs-identifier">_instance</span> </span></span>= <span class="hljs-constructor">Singleton(<span class="hljs-operator">*</span><span class="hljs-params">args</span>,<span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span><span class="hljs-module"><span class="hljs-identifier">_instance</span></span></span><span class="hljs-module-access"><span class="hljs-module"></span></span><span class="hljs-module-access"><span class="hljs-module">d</span></span>ef task(arg):    obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span></span>get<span class="hljs-constructor">_instance(<span class="hljs-params">arg</span>)</span>    print(obj)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    t = threading.<span class="hljs-constructor">Thread(<span class="hljs-params">target</span>=<span class="hljs-params">task</span>,<span class="hljs-params">args</span>=[<span class="hljs-params">i</span>,])</span>    t.start<span class="hljs-literal">()</span>obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span></span>get<span class="hljs-constructor">_instance()</span>print(obj)</code></pre><h5 id="GOLANG语境"><a href="#GOLANG语境" class="headerlink" title="GOLANG语境"></a>GOLANG语境</h5><pre><code class="hljs smali">type singleton struct &#123;&#125;var<span class="hljs-built_in"> instance </span>*singletonvar mu sync.Mutexfunc GetInstance() *singleton &#123;    mu.Lock()    defer mu.Unlock()   <span class="hljs-built_in"> if </span>instance == nil &#123;       <span class="hljs-built_in"> instance </span>= &amp;singleton&#123;&#125;     // unnecessary locking<span class="hljs-built_in"> if </span>instance already created    &#125;   <span class="hljs-built_in"> return </span>instance&#125;</code></pre><p>另一种：</p><pre><code class="hljs routeros">import (    <span class="hljs-string">&quot;sync&quot;</span>)type singleton struct &#123;&#125;var<span class="hljs-built_in"> instance </span>*singletonvar once sync.Oncefunc GetInstance() *singleton &#123;    once.<span class="hljs-keyword">Do</span>(func() &#123;       <span class="hljs-built_in"> instance </span>= &amp;singleton&#123;&#125;    &#125;)    return instance&#125;</code></pre><h5 id="C-语境-1"><a href="#C-语境-1" class="headerlink" title="C++语境"></a>C++语境</h5><p>我还没摸过C++，对力量一无所知…<br><a href="https://blog.csdn.net/hackbuteer1/article/details/7460019">https://blog.csdn.net/hackbuteer1/article/details/7460019</a></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:           CCriticalSection m_cs;<span class="hljs-keyword">public</span>:    Lock(CCriticalSection  cs) : m_cs(cs)    &#123;        m_cs.Lock();    &#125;    ~Lock()    &#123;        m_cs.Unlock();    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    Singleton();    Singleton(<span class="hljs-keyword">const</span> Singleton &amp;);    Singleton&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Singleton &amp;);<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton *<span class="hljs-title">Instantialize</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">static</span> Singleton *pInstance;    <span class="hljs-keyword">static</span> CCriticalSection cs;&#125;;Singleton* Singleton::pInstance = <span class="hljs-number">0</span>;<span class="hljs-function">Singleton* <span class="hljs-title">Singleton::Instantialize</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pInstance == <span class="hljs-literal">NULL</span>)    &#123;   <span class="hljs-comment">//double check</span>        <span class="hljs-function">Lock <span class="hljs-title">lock</span><span class="hljs-params">(cs)</span></span>;           <span class="hljs-comment">//用lock实现线程安全，用资源管理类，实现异常安全</span>        <span class="hljs-comment">//使用资源管理类，在抛出异常的时候，资源管理类对象会被析构，析构总是发生的无论是因为异常抛出还是语句块结束。</span>        <span class="hljs-keyword">if</span>(pInstance == <span class="hljs-literal">NULL</span>)        &#123;            pInstance = <span class="hljs-keyword">new</span> Singleton();        &#125;    &#125;    <span class="hljs-keyword">return</span> pInstance;&#125;</code></pre><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>步骤1、需要1个工厂类，switch语句判断产品分发情况<br>步骤2、需要具体的产品类与其抽象类。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>步骤1、创建策略类的抽象类<br>步骤2、创建具体的策略类与算法。<br>步骤3、创建context类，用于实例化策略类。<br>步骤4、在主函数中告诉context实例应该实例化哪一个策略类。</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p><strong>动态地给一个对象添加一些额外的职责，就增加功能而言，比生成子类更加灵活。</strong><br>步骤1、套娃</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><strong>将一个请求封装为一个对象，从而使得可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bottom</title>
    <link href="/2020/08/02/second/"/>
    <url>/2020/08/02/second/</url>
    
    <content type="html"><![CDATA[<p>This is abstract.</p><a id="more"></a><p>This is article text.</p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
